Raportându-ne la structurile de date studiate și cunoscute, putem spune de exemplu, despre listă, că este un obiect iterabil dar nu este un iterator. La modul cel mai general, obiectele iterabile reprezintă structuri ce permit să fie parcurse cu ajutorul buclelor repetitive.

Plecând de la o listă generală:

values = ["a", "b", "c"]

putem itera prin această structură cu ajutorul unui for:

for val in values:
	print(val, end = " ")

- rezultatul va fi reprezentat de afișarea celor trei elemente, pe aceeași linie, separate printr-un spațiu.

Alte structuri de date prin care se poate itera sunt: tuplurile, dicționarele, seturile, stringurile etc.

Putem identifica că o structură de date este iterabilă dacă conține următoarea metodă: __iter__(). Iar această existenta acestei componente se poate verifica prin apelul metodei dir(), dând ca și argument instanța ce se dorește a fi verificată. În cazul de mai sus, raportându-ne la lista noastră, putem face verificarea prin:

print(dir(values)).

În urma apelului metodei "magice" __iter__() ne va fi returnat un iterator. Putem spune despre un obiect că este iterator dacă acesta reține starea curentă în timpul unei iterații. Un iterator obține următoarea valoare pe care o poate returna cu ajutorul metodei __next__(). Această metodă NU face parte din metodele pe care listele le au la dispoziție, dar va face parte din obiectul returnat în urma apelului metodei __iter__(). Demonstrăm în acest felul lucrul menționat la începutul sub-capitolului curent: listele sunt iterabile, dar nu iteratori.

Dacă apelăm metoda __iter__() dintr-un obiect de tip listă, vom obține un iterator:

iter_values = iter(values) #echivalent cu values.__iter__()

În cadrul acestuia avem la dispoziție metoda __next__(), lucru pe care îl putem verifica cu:

print(dir(iter_values))

În continuare, putem apela metoda next() dând ca și argument iteratorul obținut mai devreme:

print(next(iter_values)) #va afișa a
print(next(iter_values)) #va afișa b

Prin faptul că la două apeluri consecutive ale metodei next() obținem valori consecutive din lista inițială observăm că obiectul iter_values își reține starea curentă la apeluri consecutive. (adică în timpul iterației)

Dacă am încerca să apelăm de 4 ori metoda next() cu ajutorul lui iter_values ne vom lovi de o excepție: StopIteration. Această excepție este tratată în mod implicit de structurile repetitive din limbaj, semnalizând ca s-a terminat colecția de date prin care se iterează.

Putem scrie în mod explicit structura implicită de tratare a excepției din spatele unui for cu ajutorul:

while True:
	try:
		val = next(iter_values)
		print(val)
	except StopIteration:
		print("Am terminat structura de date.")
		break

În timpul iterării prin valorile dintr-un iterator putem doar să avansăm, nu putem să mergem înapoi. Dacă avem nevoie de o valoare de care deja am trecut, este nevoie să generăm un nou iterator, plecând de la obiectul iterabil.


Ne putem folosi de aceste comportamente pentru a transforma propriile obiecte din proiectele noastre în unele iterabile.

#Implementarea unui iterator

În continuare vom implementa o clasă a cărei instanțe ne dorim să se comporte în mod asemănător cu funcția range() ce face parte din bibliotecile builtin.

class NewRange:

	def __init__(self, start, end):
		self.value = start
		self.end = end
	
	#Pentru a transforma instanțele clasei în unele iterabile, vom avea nevoie să folosim metoda __iter__(). 
	def __iter__(self):
		return self
	#returnăm instanța în sine întrucât mai departe vom suprascrie și metoda __next__(). Făcând acest lucru, vom putea spune despre clasa noastră că este și iterabilă și un iterator.

	def __next__(self):
	#Începem prin a verifica dacă am ajuns la finalul intervalului pe care vrem să îl parcurgem
		if self.value >= self.end:
			raise StopIteration
		current_value = self.value
		self.value += 1
		#self.value va fi responsabil cu a reține starea curentă a obiectului, știind practic care este următoarea valoare ce trebuie returnată.
		return current


Verificăm dacă implementarea de mai sus corespunde cu așteptările inițiale legate de comportamentul clasei.
nr1 = NewRange(1, 5)
for val in nr1:
	print(nr, end = " ")

În urma execuției ne așteptăm să vedem afișate valorile numerice de la 1 la 4, separate printr-un spațiu. În concluzie putem spune că am implementat un iterator corect.

O altă metodă de a itera prin valorile unei instanțe ale clasei NewRange este de a apela în mod consecutiv metoda next() pe care aceasta ne-o pune la dispoziție.

nr = NewRange(2, 10)
print(next(nr2)) #2
print(next(nr2)) #3
print(next(nr2)) #4

Dacă apelăm de suficiente ori această metodă ne vom lovi de excepția StopIteration la un moment dat.


#Generatori

Putem spune despre generatori că reprezintă implementări particulare de iteratori - orice generator este un iterator, dar reciproca nu este adevărată. Un generator reprezintă, la bază, o funcție care returnează în urma apelurilor consecutive valori dintr-o colecție de date. Acest lucru este realizat cu ajutorul cuvântului cheie yield, utilizat în detrimentul clasicului return. 

O funcție obișnuită își reia instrucțiunile din cadrul său la fiecare apel în parte. Un generator, pe de altă parte, când este apelat, va executa o serie de instrucțiuni și va reține starea în care se află, urmând ca la următorul apel să continue din acel punct.

Raportându-ne la exemplele anterioare din iteratori și obiecte iterabile, putem spune că metodele __iter__() și __next__() sunt create în mod automat.

Păstrând analogia cu funcția range(), putem defini un generator în felul următor:

def new_range(start, end):
	current_value = start
	while current_value <= end:
		yield current_value
		current_value += 1

my_gen = new_range(1, 5)
print(next(my_gen)) #1
print(next(my_gen)) #2
print(next(my_gen)) #3

Obținem practic același comportament cu cel pe care l-am implementat mai devreme în clasa NewRange.

Generatorii sunt foarte utili în momentul în care avem de prelucrat structuri foarte mari de date (sute de mii de înregistrări).

#Exercițiu iteratori și generatori

Acum că am explorat și înțeles modul în care iteratorii funcționează în Python putem pune în practică și implementări care să se axeze pe avantajele aduse de aceștia.

Mai exact, ne propunem în continuare implementarea unui generator și a unui iterator care să ruleze la infinit. În mod concret, ne dorim să putem apela metoda next() ori de câte ori avem nevoie și să ne returneze mereu o valoare numerică nouă. Echivalent putem spune că vrem să folosim instanțele de generator/iterator într-o buclă for iar aceasta să ruleze la infinit.

Atenție! În urma implementării unei bucle infinite, oprirea programului trebuie făcută în mod forțat!


#Comprehension

Operația de comprehension reprezintă o modalitate simplificată de creare a unei liste. În cadrul acestei operații putem pune și folosi diverse condiții pentru generare datelor din listele pe care le vrem create, având de asemenea posibilitatea de a crea liste noi pe baza unora existente.

Formatul cel mai general de obținere a list comprehension este
lista_noua = [secventa_date <filtru>] - în aceast format, partea de filtrare este opțională.

Ne putem folosii de operațiile de comprehension în detrimentul structurilor clasice de for. Putem observa această echivalență în următoarele exemple:

Folosindu-ne de funcțiile discutate în sub-capitolele anterioare, acest exemplu poate să fie rezolvat și în felul următor:

#Exercițiu
Plecând de la următoarele două structuri:
sir = "abcd"
val = "0123"

generați o secvență de tupluri, în care fiecare tuplu în parte să conțină o valoare din prima structură și o valoare de pe aceeași poziție din aceeași structură.

Rezultatul final trebuiă să aibă următoarea formă:
[(a, 1), (b, 2), (c, 3), (d, 4)]




